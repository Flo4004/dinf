### <u>**ВАЖНО!**</u>
<u>Нумерация вершин графа должна обязательно происходить с 0 до n-1</u>

файл graph.txt это то что подается на вход программы </n>

в файле test.txt описаны тестовые варианты

---

### Введение: Роли
В протоколе участвуют две стороны:
1.  **Prover (Доказывающий, $P$):** Знает граф $G$ и гамильтонов цикл в нем. Хочет доказать этот факт, не раскрывая сам цикл.
2.  **Verifier (Проверяющий, $V$):** Знает только граф $G$. Хочет убедиться, что $P$ не врет.

---

### Шаг 1. Криптографическая основа (RSA)

Для протокола нам нужно "спрятать" значения (0 или 1) так, чтобы их нельзя было прочитать без ключа, но можно было проверить, если ключ предъявлен. Это называется **схема обязательств (Bit Commitment)**. Мы используем RSA.

#### Математика
1.  Генерируются простые числа $p, q$.
2.  Модуль $N = p \cdot q$.
3.  Выбирается открытая экспонента $d$ (в классическом RSA это $e$, но в задании $d$).
4.  Шифрование сообщения $m$: $C = m^d \pmod N$.

#### Код
Функция `generate_rsa_keys` создает параметры.

```python
def generate_rsa_keys(bits=256):
    # Генерация простых p и q
    p = generate_prime(bits)
    q = generate_prime(bits)
    N = p * q
    phi = (p - 1) * (q - 1)
    
    # Генерация d (публичная часть обязательства)
    while True:
        d = random.randrange(3, phi)
        if gcd(d, phi) == 1:
            break
    # c (секретная часть, нужна для расшифровки, если бы мы шифровали "по-настоящему")
    c = multiplicative_inverse(d, phi)
    return N, d, c
```
**Пояснение:** $N$ и $d$ будут переданы Проверяющему. Проверяющий будет использовать их, чтобы возвести полученное от Доказывающего число в степень $d$ и сверить с обязательством.

---

### Шаг 2. Изоморфизм графов (Маскировка)

Доказывающий не может работать с исходным графом $G$, так как любое действие с ним раскроет информацию. Он создает "дублера" — граф $H$, который **изоморфен** $G$. Это значит, что структура связей та же, но вершины перемешаны.

#### Математика
Пусть $V_G = \{0, 1, \dots, n-1\}$ — вершины графа.
Генерируется случайная перестановка $\pi$ (функция замены номеров).
Матрица смежности $H$ строится так:
$$ H_{\pi(i), \pi(j)} = G_{i, j} $$
Это означает: если в $G$ было ребро между $i$ и $j$, то в $H$ будет ребро между новыми номерами $\pi(i)$ и $\pi(j)$.

#### Код (Класс Prover)

```python
def step_1_2_build_isomorphic(self):
    # Создаем случайную перестановку (массив perm)
    # perm[старый_индекс] = новый_индекс
    indices = list(range(self.n))
    random.shuffle(indices)
    self.perm = indices 
    
    # Строим матрицу смежности H
    self.H = [[0] * self.n for _ in range(self.n)]
    for i in range(self.n):
        for j in range(self.n):
            # Находим, куда перешли вершины i и j
            new_i = self.perm[i]
            new_j = self.perm[j]
            # Копируем наличие ребра (0 или 1) на новое место
            self.H[new_i][new_j] = self.G[i][j]
```
**Суть:** $H$ — это зашифрованный структурно граф $G$. Без знания `perm` найти соответствие между вершинами невозможно.

---

### Шаг 3. Кодирование и Обязательство (Commitment)

Теперь $P$ должен передать матрицу $H$ проверяющему, но в **закрытом виде**.
Если просто зашифровать 0 и 1, $V$ сможет подобрать значения перебором (всего 2 варианта). Поэтому к каждому биту добавляется "соль" — случайное число $r$.

#### Математика
Для каждой ячейки матрицы $H_{ij}$:
1.  Генерируется случайное $r_{ij}$ (64 бита).
2.  Создается сообщение $M_{ij} = r_{ij} || H_{ij}$ (конкатенация).
3.  Вычисляется обязательство $F_{ij} = (M_{ij})^d \pmod N$.

#### Код

```python
def step_3_4_encode_and_encrypt(self):
    self.H_prime = [[0] * self.n for _ in range(self.n)]
    self.F = [[0] * self.n for _ in range(self.n)]
    
    for i in range(self.n):
        for j in range(self.n):
            # 1. Генерируем соль r
            r = random.getrandbits(64)
            bit = self.H[i][j]
            
            # 2. Конкатенация (склеивание числа и бита)
            # Пример: r=123, bit=1 -> "1231" -> int(1231)
            encoded_val = int(str(r) + str(bit))
            self.H_prime[i][j] = encoded_val
            
            # 3. Шифрование (создание обязательства)
            # F[i][j] передается проверяющему
            encrypted_val = pow(encoded_val, self.d, self.N)
            self.F[i][j] = encrypted_val
    
    return self.F, self.N, self.d
```
**Результат:** Матрица $F$ отправляется к $V$. Теперь $P$ **связан обязательством**: он не может изменить значения в $H$, так как математически невозможно найти другое число $M'$, которое при возведении в степень $d$ даст то же $F_{ij}$.

---

### Шаг 4. Вызов (Challenge)

$V$ получает матрицу $F$. Он не знает, что внутри, но фиксирует её. Теперь он хочет проверить $P$. Он случайным образом выбирает один из двух вопросов. Это исключает возможность подготовки ложного ответа заранее.

#### Код (Класс Verifier)

```python
def send_challenge(self):
    # Бросок монеты: либо вопрос 1, либо вопрос 2
    challenge = random.choice([1, 2])
    return challenge
```

---

### Шаг 5. Ответ Доказывающего (Response)

В зависимости от вопроса $P$ раскрывает разную информацию.

#### Вариант А: Вопрос 1 ("Покажи цикл")
Если $P$ действительно знает цикл в $G$, он знает, где этот цикл находится в $H$ (потому что $H$ создан из $G$).
$P$ раскрывает **только** ячейки $F$, соответствующие ребрам цикла.

#### Код

```python
if challenge == 1:
    # Находим координаты цикла в графе H
    # self.cycle - индексы в G, переводим их через self.perm
    h_cycle_nodes = [self.perm[node] for node in self.cycle]
    
    response_data = []
    # Проходим по парам вершин цикла
    for k in range(len(h_cycle_nodes)):
        u = h_cycle_nodes[k]
        v = h_cycle_nodes[(k + 1) % len(h_cycle_nodes)]
        
        # Берем "сырое" значение (r || bit) из подготовленной матрицы
        val = self.H_prime[u][v]
        response_data.append((u, v, val))
    
    return response_data
```
**Важно:** $P$ не отдает ключ перестановки `perm`. $V$ видит лишь набор абстрактных вершин, соединенных в кольцо. Это не дает ему знания о цикле в исходном графе $G$.

#### Вариант Б: Вопрос 2 ("Докажи изоморфизм")
$P$ должен доказать, что он не подсунул "левый" граф с циклом. Он раскрывает **всю** матрицу и **перестановку**.

#### Код

```python
elif challenge == 2:
    # Отдаем полную матрицу расшифрованных значений и таблицу перестановки
    return (self.H_prime, self.perm)
```

---

### Шаг 6. Проверка (Verification)

$V$ проверяет математическую корректность ответа.

#### Проверка вопроса 1 (Цикл)
$V$ получает список троек `(u, v, val)`.
1.  **Проверка обязательства:** Возводит `val` в степень $d$ и сравнивает с тем, что лежит в $F[u][v]$.
    $$ val^d \pmod N \stackrel{?}{=} F_{uv} $$
2.  **Проверка бита:** Смотрит на последний символ `val`. Это должна быть `1` (ребро существует).
3.  **Проверка топологии:** Убеждается, что переданные ребра образуют замкнутый цикл длины $N$.

```python
# Verifier.verify_response (challenge == 1)
for (i, j, h_prime_val) in cycle_edges_data:
    # 1. Повторяем шифрование
    encrypted = pow(h_prime_val, self.d, self.N)
    if encrypted != self.F[i][j]:
        return False # Обман: число не соответствует матрице F
    
    # 2. Проверяем наличие ребра (бит == 1)
    s_val = str(h_prime_val)
    if not s_val.endswith('1'):
        return False # Обман: здесь нет ребра (значение 0)
```

#### Проверка вопроса 2 (Изоморфизм)
$V$ получает матрицу $H'$ и перестановку $\pi$.
1.  **Проверка всех ячеек:** Проверяет, что $H'$ соответствует зашифрованной $F$ (как выше, возведением в степень).
2.  **Восстановление $H$:** Отбрасывает случайные числа $r$, оставляя только биты.
3.  **Сверка с $G$:** Проверяет, что $H$ получается из $G$ применением $\pi$.
    $$ H_{\pi(u)\pi(v)} \stackrel{?}{=} G_{uv} $$

```python
# Verifier.verify_response (challenge == 2)
# ... проверка шифрования опущена для краткости ...

# Проверяем структурное соответствие
for i in range(n):
    for j in range(n):
        u_new = perm[i]
        v_new = perm[j]
        
        # Получаем бит из расшифрованной матрицы
        val_str = str(H_prime[u_new][v_new])
        h_bit = int(val_str[-1])
        
        # Сравниваем с исходным графом G
        if h_bit != original_G_matrix[i][j]:
             return False # Обман: графы не изоморфны
```

### Итог: Почему это работает?

*   **Полнота:** Если $P$ честен, он пройдет любую проверку.
*   **Корректность (Soundness):** Если $P$ врет (не знает цикла):
    *   Он может создать граф $H$ с циклом, но не изоморфный $G$. Тогда он попадется на вопросе №2.
    *   Он может создать граф $H$ изоморфный $G$, но не сможет показать в нем цикл. Тогда он попадется на вопросе №1.
    *   Вероятность угадать вопрос заранее — 50%. После $k$ раундов вероятность обмана $1/2^k$.
*   **Нулевое разглашение:** В вопросе №1 $V$ видит цикл в *случайном* графе. В вопросе №2 $V$ видит изоморфизм, но не видит цикла. Ни один из ответов не позволяет восстановить цикл в $G$.