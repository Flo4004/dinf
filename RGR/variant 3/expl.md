Суть протокола: Клиент доказывает Серверу, что знает пароль (секрет $s$), не передавая сам пароль. Сервер лишь проверяет математические свойства ответов Клиента.

Разберем код на две большие части: **Сервер** и **Клиент**.

---

# Часть 1. Сервер (`server.py`)

Сервер выполняет роль "Экзаменатора". Он задает вопросы (Challenge) и проверяет ответы.

### 1. Инициализация криптографических параметров

```python
print(">>> Генерация параметров системы (может занять время)...")
p = crypt_lib.generate_prime_bits(PRIME_BITS)
q = crypt_lib.generate_prime_bits(PRIME_BITS)
# Убедимся, что p != q
while p == q:
    q = crypt_lib.generate_prime_bits(PRIME_BITS)

N = p * q
```

**Что здесь происходит:**
1.  Сервер выбирает два больших простых числа $p$ и $q$.
2.  Вычисляет модуль $N = p \times q$.
3.  **Важно:** Число $N$ является *открытым параметром*. Сервер сообщит его любому, кто подключится. Безопасность схемы (как и в RSA) строится на том, что зная $N$, очень трудно вычислить исходные $p$ и $q$ (факторизация), а значит трудно извлечь квадратные корни по модулю.

### 2. Подключение клиента и отправка параметров

```python
def handle_client(conn, addr):
    # ...
    # 1. Отправляем открытые параметры системы (N) клиенту сразу после соединения
    initial_params = json.dumps({'N': N, 'rounds': ROUNDS})
    conn.sendall(initial_params.encode('utf-8'))
```

**Пояснение:**
Как только клиент подключается, он ничего не знает о математике сервера. Сервер обязан отправить ему число $N$, так как все вычисления клиента (возведение в степень, умножение) должны происходить **по модулю N** (`% N`).

### 3. Регистрация нового пользователя

```python
        if mode == 'REGISTER':
            # Регистрация: получаем v (открытый ключ) и сохраняем
            v = request.get('v')
            save_user(login, v)
            conn.sendall(b"REGISTRATION_SUCCESS")
```

**Пояснение:**
*   Клиент присылает свой логин и **открытый ключ** $v$.
*   В протоколе Фиата-Шамира $v = s^2 \pmod N$, где $s$ — секрет клиента (производная от пароля).
*   Сервер сохраняет $v$ в файл. **Сервер никогда не узнает $s$**.

### 4. Авторизация (Самая важная часть)

Если клиент хочет войти (`mode == 'LOGIN'`), начинается цикл проверки из 20 раундов (`ROUNDS`).

#### Шаг А: Получение обязательства (Commitment)
```python
            for i in range(ROUNDS):
                # Шаг 1: Получаем x (Commitment) от клиента
                # x = r^2 mod N
                msg = conn.recv(1024).decode('utf-8')
                client_data = json.loads(msg)
                x = client_data['x']
```
*   Клиент придумал случайное число $r$, возвел его в квадрат ($x = r^2$) и прислал $x$.
*   Сервер запомнил $x$. Он пока не знает, знает ли клиент $r$ или просто прислал случайное число.

#### Шаг Б: Отправка вызова (Challenge)
```python
                # Шаг 2: Сервер выбирает случайный бит e (Challenge)
                e = random.choice([0, 1])
                conn.sendall(json.dumps({'e': e}).encode('utf-8'))
```
*   Сервер бросает монетку ($e$ равно 0 или 1). Это "экзаменационный билет".
    *   Если выпадет **0**, сервер попросит показать просто $r$.
    *   Если выпадет **1**, сервер попросит показать произведение секрета на случайное число.

#### Шаг В: Проверка ответа (Verification)
```python
                # Шаг 3: Получаем y (Response) от клиента
                msg = conn.recv(1024).decode('utf-8')
                y = client_data['y']
                
                # Шаг 4: Проверка y^2 = x * v^e mod N
                left = pow(y, 2, N)
                right = (x * pow(v, e, N)) % N
                
                if left != right:
                    is_authenticated = False
                    break
```

**Математика проверки:**
Сервер проверяет равенство $y^2 \equiv x \cdot v^e \pmod N$.

*   **Ситуация 1 (e = 0):**
    Уравнение превращается в $y^2 \equiv x \cdot v^0 \equiv x \cdot 1 \equiv x$.
    Клиент должен был прислать $y = r$. Так как $x = r^2$, проверка $r^2 = r^2$ проходит успешно.
*   **Ситуация 2 (e = 1):**
    Уравнение превращается в $y^2 \equiv x \cdot v$.
    Клиент должен был прислать $y = r \cdot s$.
    Возводим ответ клиента в квадрат: $y^2 = (r \cdot s)^2 = r^2 \cdot s^2$.
    У сервера есть $x$ (это $r^2$) и $v$ (это $s^2$).
    Произведение $x \cdot v$ тоже равно $r^2 \cdot s^2$.
    Проверка проходит успешно.

**Почему это работает:** Если у злоумышленника нет $s$, он не сможет правильно ответить на вопрос $e=1$. Если он попытается схитрить и подготовиться только к $e=1$, он провалится на $e=0$. Вероятность угадать все 20 раз подряд = $1 / 2^{20}$ (ничтожно мала).

---

# Часть 2. Клиент (`client.py`)

Клиент — это "Студент", который доказывает знания, не раскрывая шпаргалку ($s$).

### 1. Генерация секрета из пароля

```python
def derive_secret(password, N):
    # Хэшируем пароль и превращаем в число
    h = hashlib.sha256(password.encode()).hexdigest()
    s = int(h, 16) % N
    if s == 0: s = 1
    return s
```

**Пояснение:**
*   Мы не храним $s$ на диске.
*   Пользователь вводит пароль $\rightarrow$ мы берем от него SHA-256 хэш $\rightarrow$ превращаем в огромное число $\rightarrow$ берем остаток от деления на $N$.
*   Это число и есть наш **секрет $s$**.

### 2. Подключение и вычисление открытого ключа

```python
        # 1. Получение открытых параметров системы от сервера
        data = sock.recv(1024).decode('utf-8')
        params = json.loads(data)
        N = params['N']
        
        # Генерация секретного ключа (s) и открытого ключа (v)
        s = derive_secret(password, N)
        v = pow(s, 2, N)
```
*   Клиент получает $N$ от сервера.
*   Вычисляет $s$ (из пароля).
*   Вычисляет публичный ключ $v = s^2 \pmod N$. Этот $v$ можно безопасно отправлять по сети. Зная $v$ и $N$, найти $s$ вычислительно невозможно (задача извлечения квадратного корня по модулю составного числа).

### 3. Цикл доказательства (Прохождение раундов)

Клиент входит в цикл `for i in range(rounds)`:

#### Шаг А: Генерация случайности и отправка обязательства
```python
                # Шаг 1: Клиент выбирает случайное r и отправляет x = r^2 mod N
                r = random.randint(1, N - 1)
                x = pow(r, 2, N)
                sock.sendall(json.dumps({'x': x}).encode('utf-8'))
```
*   $r$ — это "соль" (случайное число), одноразовое для этого раунда.
*   Мы "маскируем" $r$, возводя в квадрат, и отправляем $x$.

#### Шаг Б: Получение вызова
```python
                # Шаг 2: Получаем вызов e (0 или 1) от сервера
                server_msg = sock.recv(1024).decode('utf-8')
                e = json.loads(server_msg)['e']
```
Сервер спрашивает: "Покажи мне ответ для варианта $e$".

#### Шаг В: Вычисление ответа
```python
                # Шаг 3: Вычисляем ответ y
                if e == 0:
                    y = r
                else:
                    y = (r * s) % N
                
                sock.sendall(json.dumps({'y': y}).encode('utf-8'))
```
*   Если $e=0$, мы просто раскрываем наше случайное число $r$. Секрет $s$ не используется.
*   Если $e=1$, мы отправляем произведение $r \cdot s$.
    *   **Почему это безопасно?** Сервер получает число $y$. Поскольку $r$ — случайное число, на которое мы умножили $s$, результат $y$ тоже выглядит как абсолютно случайное число (равномерно распределенное). Сервер не может разделить $y$ на $r$, так как он не знает $r$ в этом раунде (мы передавали только $r^2$).
    *   Таким образом, мы доказали использование $s$ в формуле, но не показали само $s$.

---

### Итог

1.  **Регистрация:** Клиент отправляет квадрат своего секрета ($v = s^2$).
2.  **Вход:**
    *   Клиент прячет случайное число ($x = r^2$).
    *   Сервер просит либо открыть число ($e=0$), либо открыть число умноженное на секрет ($e=1$).
    *   Клиент отвечает.
    *   Сервер проверяет математику.
3.  **Результат:** Сервер убедился, что клиент знает $s$, но ни $s$, ни пароль никогда не передавались по сети в открытом виде.