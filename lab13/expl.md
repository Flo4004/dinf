# Алгоритм слепого голосования

Алгоритм основан на свойствах RSA и позволяет серверу подписать данные, не видя их содержимого.


### 0. Фундамент: Генерация ключей (RSA)

В основе лежит **мультипликативное свойство RSA**.
Сервер генерирует параметры.

**Математика:**
1.  Выбираются простые $P, Q$.
2.  Вычисляется модуль $N = P \times Q$.
3.  Вычисляется функция Эйлера $\phi(N) = (P-1)(Q-1)$.
4.  Выбирается **Открытый ключ $D$**, взаимнопростой с $\phi(N)$.
5.  Вычисляется **Секретный ключ $C$**, обратный к $D$: $C \times D \equiv 1 \pmod{\phi(N)}$.

**Код (`server.py`):**
```python
# Генерация параметров (N, Public_Key=D, Private_Key=C)
self.N, self.D, self.C = rsa_generate_params(min_p=1000, max_p=50000)

# Алиса запрашивает открытые ключи
N, D = self.server.get_public_key()
```

Это обеспечивает главное свойство RSA:
$$ (X^D)^C \equiv X \pmod N $$

---

### Этап 1: Подготовка бюллетеня (Алиса)

Алиса формирует "тело" бюллетеня, которое сервер должен подписать.

**Математика:**
1.  Алиса берет случайное число $rnd$ и свой голос $v$.
2.  Склеивает их: $n = rnd | v$.
3.  Вычисляет хеш $h = \text{SHA3}(n)$.
    *Важно:* $h < N$.

**Код (`client.py`):**
```python
# 1. Формируем число n = rnd | v
rnd = random.getrandbits(32) 
# Битовый сдвиг влево и добавление голоса (v)
n = (rnd << 2) | v

# 2. Вычисляем хеш h
h_bytes = hashlib.sha3_256(str(n).encode('utf-8')).digest()
h = int.from_bytes(h_bytes, byteorder='big')
h = h % N  # Приводим к модулю, чтобы h < N
```

---

### Этап 2: Ослепление / Blinding (Алиса)

Это самый важный шаг. Алиса должна спрятать $h$ перед отправкой.

**Математика:**
1.  Алиса генерирует случайный множитель $r$, такой что $\text{gcd}(r, N) = 1$.
2.  Она "шифрует" этот множитель **открытым ключом сервера $D$**: $r^D \pmod N$.
3.  Умножает хеш бюллетеня на зашифрованный множитель:
    $$ h' = (h \times r^D) \pmod N $$

Благодаря мультипликативности RSA: $(A \times B)^C = A^C \times B^C$. Это позволит нам позже разделить подпись на две части.

**Код (`client.py`):**
```python
# Генерация взаимнопростого r
while True:
    r = random.randint(2, N - 1)
    if cl.mod_inverse(r, N) != 0: 
        break

# Ослепление: h' = (h * r^D) mod N
# Используем pow(base, exp, mod)
factor = pow(r, D, N)
h_prime = (h * factor) % N

# Алиса отправляет h_prime на сервер
```

**Суть:** Сервер видит $h'$, которое выглядит как случайный шум. Он не знает $r$, поэтому не может узнать $h$.

---

### Этап 3: Слепая подпись (Сервер)

Сервер подписывает "слепое" сообщение своим **Секретным ключом $C$**.

**Математика:**
Сервер вычисляет:
$$ s' = (h')^C \pmod N $$

Подставим значение $h'$ из Этапа 2, чтобы понять физику процесса:
$$ s' = (h \times r^D)^C \pmod N $$
$$ s' = h^C \times (r^D)^C \pmod N $$

Так как $(r^D)^C = r^{D \times C} = r^1 = r$, формула превращается в:
$$ s' = h^C \times r \pmod N $$

Сервер вернул подпись $h^C$, но она "склеена" с множителем $r$.

**Код (`server.py`):**
```python
def sign_blind_ballot(self, voter_id, blind_hash):
    # Проверка прав доступа...
    
    # Подпись секретным ключом C: s' = (h'^C) mod N
    s_prime = pow(blind_hash, self.C, self.N)
    
    return s_prime
```

---

### Этап 4: Снятие ослепления / Unblinding (Алиса)

Алиса получает $s'$. Она знает $r$, поэтому может убрать его из уравнения.

**Математика:**
1.  Найти обратный элемент $r^{-1}$, такой что $r \times r^{-1} \equiv 1 \pmod N$.
2.  Умножить "грязную" подпись $s'$ на $r^{-1}$:
    $$ s = (s' \times r^{-1}) \pmod N $$

Подставим $s'$ из Этапа 3:
$$ s = (h^C \times r) \times r^{-1} \pmod N $$
$$ s = h^C \times (r \times r^{-1}) \pmod N $$
$$ s = h^C \times 1 = h^C \pmod N $$

**Результат:** У Алисы на руках число $s = h^C$.
Это чистая, валидная подпись сервера под её бюллетенем $h$. Сервер никогда не видел $h$ в открытом виде, но его цифровая подпись стоит именно под ним.

**Код (`client.py`):**
```python
# Вычисление обратного элемента для r
r_inv = cl.mod_inverse(r, N)

# Снятие ослепления: s = s' * r^(-1) mod N
s = (s_prime * r_inv) % N

# Теперь у Алисы есть пара <n, s>, которую она шлет анонимно
```

---

### Этап 5: Проверка и учет голоса (Сервер)

Алиса отправляет пару $\langle n, s \rangle$ через анонимный канал. Сервер должен проверить подпись.

**Математика:**
Сервер знает $n$, $s$ и свой **Открытый ключ $D$**.
1.  Вычисляет хеш: $h_{check} = \text{SHA3}(n)$.
2.  Проверяет подпись, возводя $s$ в степень $D$:
    $$ \text{val} = s^D \pmod N $$

Если $s$ действительно равно $h^C$, то:
$$ \text{val} = (h^C)^D = h^{C \times D} = h^1 = h $$

3.  Сравнивает: $h_{check} \stackrel{?}{=} \text{val}$.

**Код (`server.py`):**
```python
def receive_filled_ballot(self, n, s):
    # 1. Считаем хеш от пришедшего n
    h_bytes = hashlib.sha3_256(str(n).encode('utf-8')).digest()
    h = int.from_bytes(h_bytes, byteorder='big') % self.N

    # 2. Расшифровываем подпись s публичным ключом D
    # val = s^D mod N
    decrypted_signature = pow(s, self.D, self.N)
    
    # 3. Сравниваем
    if h == decrypted_signature:
        # Голос принят
        self.ballot_box.append(n)
```

### Итог безопасности

Сервер не может связать **выдачу** бюллетеня с его **приемом**:
*   При выдаче он видел число $h'$ (большое случайное число).
*   При приеме он видит число $h$ (другое число).
*   Связующее звено $r$ известно только Алисе.

Таким образом, сервер знает, **что** Алиса проголосовала (он выдал ей подпись), но не знает **как** (не может найти её бюллетень в урне).

### Итог по безопасности

1.  **Почему это анонимно?**
    Сервер хранит у себя в логах пару «Алиса — $h'$» (где $h'$ — это ослепленный хеш).
    В урну для голосования падает бюллетень «$n$ — $s$» (где хеш равен $h$).
    Сервер не может математически связать $h'$ и $h$, потому что он не знает $r$. Для сервера $h'$ и $h$ — просто два разных числа.

2.  **Почему нельзя подделать голос?**
    Алиса может сгенерировать любое $n$ (например, с 1000 голосов "ЗА"). Но чтобы голос засчитали, ей нужно число $s$, такое что $s^D = \text{SHA3}(n)$.
    Чтобы найти такое $s$, нужно вычислить корень степени $D$ из хеша, что невозможно без знания секретного ключа $C$ (задача RSA). Единственный способ получить $s$ — попросить сервер подписать заготовку. А сервер подписывает только одну заготовку для одного пользователя.