

---

### Общая концепция

Протокол решает две главные задачи:
1.  **Честное перемешивание (The Shuffle):** Как убедиться, что колода перемешана действительно случайно, и никто (даже сервер) не знает порядок карт?
2.  **Секретная раздача (The Deal):** Как раздать карты так, чтобы только вы знали свои карты, а другие игроки (и сервер) не могли их подсмотреть?

Это достигается с помощью коммутативного шифрования. Представьте, что у каждого игрока есть свой уникальный "замок" (ключ шифрования `C`) и "ключ от замка" (ключ расшифровки `D`). Свойство коммутативности означает, что неважно, в каком порядке навешивать замки — снимать их можно в любом порядке, и результат будет один и тот же.

---

### Фаза 0: Подготовка (На стороне клиента, до начала игры)

Прежде чем игра начнется, каждый клиент должен подготовить словарь, чтобы в будущем понимать, что означают расшифрованные числовые значения.

#### **Процесс:**
Каждый клиент локально, без участия сервера, создает стандартную, упорядоченную колоду карт и сопоставляет каждой карте уникальное числовое значение.

#### **Функция в `script.js`:** `generateCardIdentityMap()`
```javascript
function generateCardIdentityMap() {
    const suits = ['♠', '♥', '♦', '♣'];
    const ranks = ['2', '3', ..., 'A'];
    let card_id = 0;
    const newMap = {};
    for (const suit of suits) {
        for (const rank of ranks) {
            newMap[100 + card_id] = rank + suit; // -> { 100: '2♠', 101: '3♠', ... }
            card_id++;
        }
    }
    return newMap;
}
```
**Объяснение:**
Эта функция выполняется один раз при загрузке страницы. Она создает объект `playerCardMap`, который будет служить локальным словарем. Поскольку алгоритм стандартный и одинаковый для всех, у каждого игрока и у сервера будет идентичное понимание, что, например, число `115` — это всегда `A♠`. **Эта информация никогда не передается по сети.**

---

### Фаза 1: Старт Игры и Генерация Криптографических Ключей

Сервер инициирует игру и создает общие математические параметры. Клиенты, получив эти параметры, генерируют свои личные секретные ключи.

#### **Процесс:**
1.  Сервер генерирует большое простое число `P` (модуль для всех вычислений).
2.  Сервер создает у себя начальную, отсортированную и нешифрованную колоду.
3.  Сервер отправляет число `P` всем подключенным клиентам.
4.  Каждый клиент, получив `P`, генерирует свою пару ключей: `C` (для шифрования) и `D` (для расшифровки). Они связаны свойством `(C * D) mod (P - 1) = 1`.

#### **Функции:**
*   **`mental_poker_game.py`: `start_game()`**
    *   **`generate_sophie_germain_prime()`:** Создает криптостойкое простое число `P`.
    *   **`initialize_deck()`:** Создает на сервере эталонную колоду карт с числовыми значениями и записывает ее в лог (`ЛОГИРОВАНИЕ 1`).
    *   **`socketio.emit('receive_prime', ...)`:** Отправляет `P` всем игрокам.

*   **`script.js`: `socket.on('receive_prime', ...)`**
    *   Этот обработчик, получив `P`, вызывает функцию `generateKeys()`.

*   **`script.js`: `generateKeys()`**
    ```javascript
    function generateKeys() {
        const pMinusOne = currentP - 1n;
        // ... находит случайное C, взаимно простое с (P-1)
        playerC = BigInt(...);
        // ... вычисляет D как обратное к C по модулю (P-1)
        playerD = modInverse(playerC, pMinusOne);
    }
    ```
    **Объяснение:**
    Это сердце личной криптографии игрока. `playerC` — это ваш секретный "замок". `playerD` — ваш секретный "ключ". Вы никогда и никому не сообщаете эти значения до самого конца игры.

---

### Фаза 2: Шифрование и Перемешивание Колоды

Это коллективный процесс, в результате которого получается честно перемешанная и полностью зашифрованная колода.

#### **Процесс:**
1.  Сервер отдает отсортированную колоду **Игроку 1**.
2.  **Игрок 1** шифрует каждую карту своим ключом `C1`, затем **перемешивает массив карт** и отправляет результат на сервер.
3.  Сервер получает колоду (уже зашифрованную и перемешанную) и отдает ее **Игроку 2**.
4.  **Игрок 2** берет каждую, *уже зашифрованную*, карту и шифрует ее поверх своим ключом `C2`, снова **перемешивает массив** и отправляет на сервер.
5.  Процесс повторяется для всех игроков.

#### **Функции:**
*   **`mental_poker_game.py`: `start_encryption_phase()`**
    *   Просто запускает процесс, отправляя колоду первому игроку.

*   **`script.js`: `socket.on('encrypt_cards', ...)` -> `encryptCards()`**
    ```javascript
    function encryptCards(cards) {
        // 1. Шифрование каждой карты
        const encryptedCards = cards.map(card => ({ ...card,
            encrypted_value: Number(modPow(..., playerC, currentP))
        }));
        // 2. Перемешивание массива (алгоритм Фишера-Йетса)
        for (let i = encryptedCards.length - 1; i > 0; i--) { ... }
        socket.emit('encrypted_cards', ...);
    }
    ```
    **Объяснение:**
    Клиент выполняет два действия: криптографическое "запутывание" значения каждой карты и физическое перемешивание их порядка в списке.

*   **`mental_poker_game.py`: `handle_encrypted_cards()`**
    *   Получает колоду от текущего игрока, **детально логирует ее состояние** (`ЛОГИРОВАНИЕ 2`) и передает ее следующему игроку. Когда все игроки закончили, он сохраняет финальную колоду в `self.deck`.

---

### Фаза 3: Раздача Карт

Сервер, не зная порядка карт, раздает их игрокам.

#### **Процесс:**
Сервер берет по две карты с конца полностью зашифрованной и перемешанной колоды и назначает их каждому игроку.

#### **Функция в `mental_poker_game.py`:** `start_card_dealing()`
```python
def start_card_dealing(self):
    self._write_to_log("--- 3. DEALING CARDS ...")
    for player_id in self.player_order:
        player_cards = [self.deck.pop() for _ in range(2)]
        self.players[player_id]['cards'] = player_cards
        # ... детальное логирование зашифрованных значений
```
**Объяснение:**
Так как колода была перемешана много раз, `deck.pop()` выдает случайные карты. Сервер записывает в лог, какие именно зашифрованные "кляксы" (числа) он раздал (`ЛОГИРОВАНИЕ 3`), но сам не знает, что они означают.

---

### Фаза 4: Круговая Расшифровка Личных Карт

Самый сложный, но важный этап. Игроки помогают друг другу "снять чужие замки", чтобы в итоге каждый мог открыть свой.

#### **Процесс (на примере Игрока А):**
1.  **Игрок А** хочет увидеть свои карты. Но они зашифрованы ключами всех игроков (`C_A`, `C_B`, `C_C`...). Он не может их расшифровать в одиночку.
2.  Сервер организует "круг": он берет карты **Игрока А** и передает их **Игроку Б**.
3.  **Игрок Б** применяет к этим картам свой ключ расшифровки `D_B`, снимая свой "замок". Он отправляет частично расшифрованные карты обратно на сервер.
4.  Сервер передает их **Игроку В**. **Игрок В** снимает свой замок `D_B` и т.д.
5.  Когда все, кроме самого **Игрока А**, сняли свои замки, сервер отправляет финальные, почти расшифрованные карты **Игроку А**.
6.  **Игрок А** применяет свой ключ `D_A`, снимает последний замок, получает исходное числовое значение (например, `115`) и, используя свой локальный словарь `playerCardMap`, узнает, что это `A♠`. **Эта информация остается у него.**

#### **Функции:**
*   **`mental_poker_game.py`: `start_private_cards_decryption()` и `_start_decryption_for_current_target()`**
    *   Организуют эти "круги" для каждого игрока по очереди.

*   **`script.js`: `socket.on('decrypt_cards', ...)` -> `decryptCards()`**
    *   Когда вы получаете чужие карты для расшифровки, эта функция применяет ваш ключ `D`, чтобы снять ваш "замок", и отправляет результат обратно.

*   **`mental_poker_game.py`: `handle_decrypted_cards()` (блок `phase == 'private'`)**
    *   Управляет передачей карт по кругу, логируя промежуточные зашифрованные значения (`ЛОГИРОВАНИЕ 4`).

*   **`script.js`: `socket.on('final_private_decryption', ...)`**
    *   **Ключевой момент!** Вы получаете свои карты, зашифрованные только вашим ключом. Вы применяете `playerD`, получаете исходное число, смотрите его в `playerCardMap` и узнаете свою карту. **Никакой информации об этом на сервер не уходит.**

---

### Фаза 5: Раздача и Расшифровка Общих Карт (Флоп, Терн, Ривер)

Процесс очень похож на расшифровку личных карт, но с одним отличием: результат должен быть виден всем.

#### **Процесс:**
1.  Сервер берет из колоды 3 карты для флопа.
2.  Он запускает такой же "круг", как и для личных карт: **Игрок А** снимает свой замок, передает серверу, тот передает **Игроку Б** и т.д.
3.  Когда **все игроки** сняли свои замки, сервер получает полностью расшифрованные числовые значения.
4.  Сервер использует свою копию словаря, чтобы узнать "лица" карт, и рассылает эту публичную информацию всем игрокам.

#### **Функции:**
*   **`mental_poker_game.py`: `deal_table_cards()` и `start_table_cards_decryption()`**
    *   Запускают процесс. Сервер логирует, какие зашифрованные карты он выложил на стол (`ЛОГИРОВАНИЕ 5`).
*   **`mental_poker_game.py`: `handle_decrypted_cards()` (блок `phase == 'table'`)**
    *   Управляет кругом расшифровки и в конце обновляет `self.table_cards` и рассылает `game_state`.

---

### Фаза 6: Завершение и Аудит

Игра заканчивается, и наступает время раскрыть все секреты для возможности проверки.

#### **Процесс:**
1.  Сервер объявляет о завершении игры.
2.  Он отправляет всем клиентам запрос на их секретные ключи.
3.  Каждый клиент отправляет свои ключи `C` и `D` на сервер.
4.  Сервер записывает все ключи в финальный лог-файл.

#### **Функции:**
*   **`mental_poker_game.py`: `complete_game()` и `request_keys_from_players()`**
    *   Управляют завершением и запросом ключей.

*   **`script.js`: `socket.on('request_keys', ...)` -> `automaticallySubmitKeys()`**
    *   Отправляет ключи `C` и `D` на сервер.

*   **`mental_poker_game.py`: `handle_player_keys()` и `_write_keys_to_log()`**
    *   Собирает ключи от всех игроков и записывает их в лог (`ЛОГИРОВАНИЕ 6`), завершая формирование файла для аудита.

Теперь, имея этот лог, любой сторонний наблюдатель может математически воспроизвести всю игру и убедиться, что ни один из участников не жульничал.